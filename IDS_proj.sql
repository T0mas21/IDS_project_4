--zadání č.4 - Sklad
grant all on obsahobjednavky to xjanec35;
grant all on zbozi to xjanec35;
grant all on dodavka to xjanec35;
grant all on dodavatel to xjanec35;
grant all on objednavka to xjanec35;
grant all on precenuje to xjanec35;
grant all on faktura to xjanec35;
grant all on vydejka to xjanec35;
grant all on prepravka to xjanec35;
grant all on doklad to xjanec35;
grant all on ucetni to xjanec35;
grant all on skladnik to xjanec35;
grant all on zamestnanec to xjanec35;
/*
grant all on obsahobjednavky to xkocma09;
grant all on zbozi to xkocma09;
grant all on dodavka to xkocma09;
grant all on dodavatel to xkocma09;
grant all on objednavka to xkocma09;
grant all on precenuje to xkocma09;
grant all on faktura to xkocma09;
grant all on vydejka to xkocma09;
grant all on prepravka to xkocma09;
grant all on doklad to xkocma09;
grant all on ucetni to xkocma09;
grant all on skladnik to xkocma09;
grant all on zamestnanec to xkocma09;
*/

ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD';
DROP TABLE obsahobjednavky;
DROP TABLE zbozi;
DROP TABLE dodavka;
DROP TABLE dodavatel;
DROP TABLE objednavka;
DROP TABLE precenuje;
DROP TABLE faktura;
DROP TABLE vydejka;
DROP TABLE prepravka;
DROP TABLE doklad;
DROP TABLE ucetni;
DROP TABLE skladnik;
DROP TABLE zamestnanec;


CREATE TABLE zamestnanec(
  id_zamestnanec INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_vedouci INTEGER NULL,
  jmeno VARCHAR(20),
  prijmeni VARCHAR(50),
  plat INTEGER CHECK ( plat > 0 ),
  narozeni VARCHAR(6),-- <--\
  za_lomitkem INTEGER,-- <--- dohromady rč bezlomítka
  pozice INTEGER,
  FOREIGN KEY(id_vedouci) REFERENCES zamestnanec(id_zamestnanec) ON DELETE CASCADE
);

CREATE TABLE skladnik(
    id_skladnik INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_glob INTEGER,
    FOREIGN KEY (id_glob) REFERENCES zamestnanec(id_zamestnanec)
);

CREATE TABLE ucetni(
    id_ucetni INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_glob INTEGER,
    FOREIGN KEY (id_glob) REFERENCES zamestnanec(id_zamestnanec)
);

CREATE TABLE doklad(
    cislo_dokladu INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ico_skladu INTEGER NULL,       -- <--\
    adresa_skladu VARCHAR(50) NULL,-- <---info o zakaznikovi
    id_ucetni INTEGER,
    typ_dokladu integer,
    FOREIGN KEY(id_ucetni) REFERENCES ucetni(id_ucetni) --spravuje
);

CREATE TABLE prepravka(
    misto INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    expirace DATE,
    id_skladnik INTEGER,
    FOREIGN KEY(id_skladnik) REFERENCES skladnik(id_skladnik)  --kontroluje
);

CREATE TABLE vydejka(
    id_vydejka INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    cislo_dokladu INTEGER,
    FOREIGN KEY (cislo_dokladu) REFERENCES doklad(cislo_dokladu)
);

CREATE TABLE faktura(
    id_faktura INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    cislo_dokladu INTEGER,
    ico_skladu INTEGER NULL,          -- <--\
    adresa_skladu VARCHAR(50),   -- <---info o skladu
    FOREIGN KEY (cislo_dokladu) REFERENCES doklad(cislo_dokladu)
);

CREATE TABLE precenuje(
    id_operace INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_vedouci INTEGER,
    nova_cena INTEGER,
    FOREIGN KEY(id_vedouci) REFERENCES skladnik(id_skladnik)
);

CREATE TABLE objednavka(
    cislo_objednavky INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_skladnik INTEGER,
    id_faktura INTEGER,
    FOREIGN KEY(id_skladnik) REFERENCES skladnik(id_skladnik), --vychystava
    FOREIGN KEY (id_faktura) REFERENCES faktura(id_faktura)
);

CREATE TABLE dodavatel(
    ico INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nazev VARCHAR(255)
);

CREATE TABLE dodavka(
    id_dodavka INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    datum TIMESTAMP, -- zahrnuje datum i cas
    id_faktura INTEGER,
    id_dodavatel INTEGER,
    FOREIGN KEY(id_faktura) REFERENCES faktura(id_faktura), --je placena
    FOREIGN KEY(id_dodavatel) REFERENCES dodavatel(ico)
);

CREATE TABLE zbozi(
    kod INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_prepravka INTEGER,
    id_vydejka INTEGER NULL,
    typ VARCHAR(20),--mysleno jako nazev
    mnozstvi INTEGER,
    cena INTEGER,
    id_preceneno INTEGER NULL,
    id_dodavka INTEGER,
    FOREIGN KEY(id_preceneno) REFERENCES precenuje(id_operace), --precenuje
    FOREIGN KEY(id_prepravka) REFERENCES prepravka(misto), --je skladovano
    FOREIGN KEY(id_vydejka) REFERENCES vydejka(id_vydejka), --shrnuje
    FOREIGN KEY(id_dodavka) REFERENCES dodavka(id_dodavka) --privazi
);

--obsahuje
CREATE TABLE obsahobjednavky(
    id INTEGER GENERATED BY DEFAULT AS IDENTITY,
    mnozstvi INTEGER,
    id_zbozi INTEGER,
    id_objednavka INTEGER,
    FOREIGN KEY(id_zbozi) REFERENCES zbozi(kod),
    FOREIGN KEY(id_objednavka) REFERENCES objednavka(cislo_objednavky)
);

--musi mit alespon 6 cislic, aby bylo vetsi
ALTER TABLE ZAMESTNANEC ADD CONSTRAINT num_check CHECK ( CAST(narozeni AS INT) > 10000);
--den
ALTER TABLE ZAMESTNANEC ADD CONSTRAINT rc_checkD CHECK ( za_lomitkem > 0 AND (MOD((CAST(narozeni AS INT)-5000), 100)) BETWEEN 0 AND 32);
--mesic
ALTER TABLE ZAMESTNANEC ADD CONSTRAINT rc_checkM CHECK ( ((MOD((CAST(narozeni AS INT)-5000), 10000)/100) BETWEEN 0 AND 13) OR (MOD(CAST(narozeni AS INT), 10000)/100) BETWEEN 0 AND 13);
--delitelnost 11
ALTER TABLE zamestnanec ADD CONSTRAINT rc_checkdiv CHECK (MOD(CAST(narozeni as INT)*10000 + za_lomitkem, 11) = 0 );

create or replace trigger z_ins
    after insert on
    zamestnanec
    for each row
    declare
        id integer;
        poz integer;
    begin
        id := :new.id_zamestnanec;
        poz := :new.pozice;
        if poz = 1 then
            insert into skladnik values (default, id);
        else
            insert into ucetni values (default, id);
        end if;
    end;
/

create or replace trigger d_ins
    after insert on
    doklad
    for each row
    declare
        id integer;
        typ_d integer;
    begin
        id := :new.cislo_dokladu;
        typ_d := :new.typ_dokladu;
        if typ_d = 1 then
            insert into faktura values (default, id, 62222, 'Brnenska 3');
        else
            insert into vydejka values (default, id);
        end if;
    end;
/

--skladnik
INSERT INTO zamestnanec VALUES (1, NULL, 'Jan', 'Novak', 30000, '020809', 4084, 1);
INSERT INTO zamestnanec VALUES (2, 1, 'Karel', 'Novotny', 20000, '020809', 4084, 1);
INSERT INTO zamestnanec VALUES (3, 1, 'Emil', 'Psenka', 20000, '020809', 4084, 1);

--ucetni
INSERT INTO zamestnanec VALUES (4, 1, 'Jana', 'Novakova', 25000, '736028', 5163, 2);
INSERT INTO zamestnanec VALUES (5, 1, 'Pavla', 'Lukasova', 25000, '736028', 5163, 2);

--dodavatel
INSERT INTO dodavatel VALUES (62223, 'RandomFirmaSOvocem');
INSERT INTO dodavatel VALUES (78459, 'Dodavatel2');
INSERT INTO dodavatel VALUES (55896, 'TretiStrana');

--vydejka
INSERT INTO doklad VALUES (DEFAULT, NULL, NULL, 1, 2);
INSERT INTO doklad VALUES (DEFAULT, NULL, NULL, 1, 2);

--faktura
INSERT INTO doklad VALUES (DEFAULT, 62223, 'Husova 4', 1, 1);
INSERT INTO doklad VALUES (DEFAULT, 78459, 'Prazakova 16', 1, 1);

INSERT INTO doklad VALUES (DEFAULT, NULL, 'Na Rohu 8', 1, 1);
INSERT INTO doklad VALUES (DEFAULT, NULL, 'Nadrazni 5', 1, 1);
INSERT INTO doklad VALUES (DEFAULT, NULL, 'Blabla 10', 2, 1);

--prepravka
INSERT INTO prepravka VALUES(DEFAULT, '2023-06-09', 2);
INSERT INTO prepravka VALUES(DEFAULT, '2023-07-09', 2);
INSERT INTO prepravka VALUES(DEFAULT, '2023-06-08', 3);
INSERT INTO prepravka VALUES(DEFAULT, '2023-09-10', 1);

--dodavka
INSERT INTO dodavka VALUES (DEFAULT, '06-08-2023 23:03:20', 1, 62223);
INSERT INTO dodavka VALUES (DEFAULT, '05-08-2023 12:00:00', 1, 55896);

--zbozi
INSERT INTO zbozi VALUES (DEFAULT, 1, NULL, 'jablko', 100, 10, NULL, 1);
INSERT INTO zbozi VALUES (DEFAULT, 1, NULL, 'hruska', 100, 8, NULL, 1);
INSERT INTO zbozi VALUES (DEFAULT, 2, NULL, 'zeli', 100, 35, NULL, 2);
INSERT INTO zbozi VALUES (DEFAULT, 2, NULL, 'mrkev', 100, 15, NULL, 2);
INSERT INTO zbozi VALUES (DEFAULT, 3, NULL, 'banan', 100, 23, NULL, 1);
INSERT INTO zbozi VALUES (DEFAULT, 4, NULL, 'redkev', 100, 42, NULL, 2);
INSERT INTO zbozi VALUES (DEFAULT, 1, NULL, 'celer', 100, 40, NULL, 2);
INSERT INTO zbozi VALUES (DEFAULT, 3, NULL, 'citron', 100, 50, NULL, 1);
INSERT INTO zbozi VALUES (DEFAULT, 3, NULL, 'pomeranc', 100, 12, NULL, 1);
INSERT INTO zbozi VALUES (DEFAULT, 4, NULL, 'petrzel', 100, 6, NULL, 2);

--objednavka
INSERT INTO objednavka VALUES (DEFAULT, 1, 3);
INSERT INTO objednavka VALUES (DEFAULT, 2, 4);
INSERT INTO objednavka VALUES (DEFAULT, 2, 5);

--m:n obsah -id-mn-zb-ob
INSERT INTO obsahobjednavky VALUES (DEFAULT, 5, 1, 1);
INSERT INTO obsahobjednavky VALUES (DEFAULT, 5, 2, 1);

INSERT INTO obsahobjednavky VALUES (DEFAULT, 1, 5, 2);
INSERT INTO obsahobjednavky VALUES (DEFAULT, 10, 8, 2);
INSERT INTO obsahobjednavky VALUES (DEFAULT, 3, 4, 2);

INSERT INTO obsahobjednavky VALUES (DEFAULT, 20, 3, 3);
INSERT INTO obsahobjednavky VALUES (DEFAULT, 35, 9, 3);

SELECT r.jmeno, r.prijmeni, r.plat, r.rodne_cislo, r.vedouci, 'skladnik' as pozice FROM skladnik join
(SELECT z.id_zamestnanec, z.jmeno, z.prijmeni, z.plat, CONCAT(z.narozeni, CONCAT('/', CAST(z.za_lomitkem as varchar(4)))) as rodne_cislo,CASE when v.jmeno is null then 'vedouci' else CONCAT(v.jmeno,CONCAT(' ', v.prijmeni)) end as vedouci from zamestnanec z left join zamestnanec v on z.id_vedouci = v.id_zamestnanec) r
ON r.id_zamestnanec = skladnik.id_glob
UNION
SELECT r.jmeno, r.prijmeni, r.plat, r.rodne_cislo, r.vedouci, 'ucetni' as pozice FROM ucetni join
(SELECT z.id_zamestnanec, z.jmeno, z.prijmeni, z.plat, CONCAT(z.narozeni, CONCAT('/', CAST(z.za_lomitkem as varchar(4)))) as rodne_cislo,CASE when v.jmeno is null then 'vedouci' else CONCAT(v.jmeno,CONCAT(' ', v.prijmeni)) end as vedouci from zamestnanec z left join zamestnanec v on z.id_vedouci = v.id_zamestnanec) r
ON r.id_zamestnanec = ucetni.id_glob;

create or replace procedure vypis_zamestnancu
as
    v_id_zamestnanec zamestnanec.id_zamestnanec%type;
    v_jmeno zamestnanec.jmeno%type;
    v_prijmeni zamestnanec.prijmeni%type;
    cursor cur_zamestnanec is
        select id_zamestnanec,jmeno, prijmeni
        from zamestnanec;
begin
    open cur_zamestnanec;

    loop
        fetch cur_zamestnanec into v_id_zamestnanec, v_jmeno, v_prijmeni;
        exit when cur_zamestnanec%notfound;

    dbms_output.put_line(v_id_zamestnanec || ' ' || v_jmeno || ' ' || v_prijmeni);
    end loop;

    close cur_zamestnanec;
end;

create or replace procedure kontrola_zasob(id_zb in integer, mnozstvi in integer)
as
    cursor c_zbozi is
        select sum(mnozstvi) from zbozi where kod = id_zb;
        celkem integer;
        malo_zasob exception;
begin

    open c_zbozi;
    fetch c_zbozi into celkem;
    close c_zbozi;

    if mnozstvi > celkem then
        raise malo_zasob;
    end if;
    --změna zásob
    exception
        when malo_zasob then
            dbms_output.put_line('Nedostatek zasob ve skladu');
end;
/

begin
    vypis_zamestnancu();
    kontrola_zasob(1, 200);
end;

with pom_table(prumerny_plat) as
 (select avg(plat) from zamestnanec)
  select jmeno, prijmeni, plat,
         case when plat > pom_table.prumerny_plat then 'nadprumer'
    	 	  when plat = pom_table.prumerny_plat then 'prumer'
              else 'podprumer' end as platova_trida
  FROM zamestnanec, pom_table;
--roztřídí zaměstnance podle platů

explain plan for
    SELECT P.jmeno, P.prijmeni, COUNT(*) as ToDo FROM prepravka B
JOIN (SELECT S.id_skladnik, Z.jmeno, Z.prijmeni from skladnik S JOIN zamestnanec Z ON S.id_glob = Z.id_zamestnanec) P
ON B.id_skladnik = P.id_skladnik
GROUP BY P.jmeno, P.prijmeni
ORDER BY ToDo DESC;

select * from table (dbms_xplan.display);